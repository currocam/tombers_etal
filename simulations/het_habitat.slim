initialize() {
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	// Simulate a 1 Morgan chromosome
	initializeGenomicElement(g1, 0, 1e8 - 1);
	initializeRecombinationRate(1e-8);
	initializeMutationRate(0.0);
	// Define constants:
	defineConstantIfInteractive("NE", 5000); // Number of individuals
	defineConstantIfInteractive("SM", 0.01); // Mate choice
	defineConstantIfInteractive("SD", 0.05); // Dispersal
	defineConstant("SK", SM); // Density-selection
	// Set up spatial interaction type
	// Individuals within a small radious can mate
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SM*3);
	i1.setInteractionFunction("n", 1.0, SM);
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SK*3);
	i2.setInteractionFunction("n", 1.0, SK);
	defineConstant("RUNTIME", 1000);
	defineConstant("GRANULARITY", 100);
	defineGlobal("EMPIRICAL_DENSITY", float(RUNTIME));
	defineGlobal("EMPIRICAL_DISPERSAL", float(RUNTIME));
	defineConstantIfInteractive("OUTPATH", "out.trees");

}

mateChoice() {
	// Spatial mate choice based on interaction strength
	return i1.strength(individual);
}

modifyChild() {
	pos = child.spatialPosition;
	child.setSpatialPosition(p1.pointDeviated(1, pos, "reprising", INF, "n", SD));
	pos = child.spatialPosition;
	prev = sample(c(parent1, parent2), 1).spatialPosition;
	child.tagF = sqrt(sum((prev-pos)^2));
	return T;
}



1 early() {
	sim.addSubpop("p1", NE);
	p1.setSpatialBounds(c(-1, -1, 1, 1));
	// Simple squared-like area
	n = GRANULARITY * GRANULARITY;
	habitat_suitability = ifelse(runif(n)<0.99, 0.01, 1.0);
	habitat_suitability = matrix(habitat_suitability, ncol=GRANULARITY);
	map = p1.defineSpatialMap("mapHabitat", "xy", habitat_suitability, interpolate=T,
		valueRange=c(0.0, 1.0), colors=c("white", "black"));
	defineConstant("HABITAT_MAP", map);
	defineConstant("FRACTION_SUITABILITY", mean(habitat_suitability));
	p1.individuals.setSpatialPosition(p1.pointUniformWithMap(NE, HABITAT_MAP));
	i1.evaluate(p1);
}

early() {
	i2.evaluate(p1);
	// spatial competition provides density-dependent selection
	inds = p1.individuals;
	competition = i2.localPopulationDensity(inds);
	inds.fitnessScaling = p1.individualCount / competition;
}


1: late() {
	inds = p1.individuals;
	prevPos = inds.spatialPosition;
	i1.evaluate(p1);
	EMPIRICAL_DENSITY[sim.cycle-1] =  mean(i1.localPopulationDensity(p1.individuals));
	EMPIRICAL_DISPERSAL[sim.cycle-1] = 	mean(inds.tagF);
}

RUNTIME late() {
	// We have to account for differences between the dispersal gestating mate - offspring
	// and the non-gestating mate - offspring
	defineConstant("EXP_SIGMA", sqrt(SD^2 + SM^2 / 2));
	defineConstant("OBS_SIGMA", mean(EMPIRICAL_DISPERSAL));
	area = (p1.spatialBounds[2] - p1.spatialBounds[0]) * (p1.spatialBounds[3] - p1.spatialBounds[1]);
    // This is the expected density if individuals are placed randomly (which are not)
	defineConstant("EXP_D", NE / area);
    // This is for debugging the meaning of effective density
	defineConstant("OBS_D", mean(EMPIRICAL_DENSITY));


	sim.treeSeqOutput(
		OUTPATH,
		metadata=Dictionary(
			"EXP_SIGMA", EXP_SIGMA, "OBS_SIGMA", OBS_SIGMA,
			"EXP_D", EXP_D, "OBS_D", OBS_D,
			"FRACTION_SUITABILITY", FRACTION_SUITABILITY)
		);
}

function (void)defineConstantIfInteractive(string$ symbol, * value){
	if (exists("slimgui")) defineConstant(symbol, value);
}